# General Notes on the Expression Language

This document is a lightweight explanation of the Expression Language
used with the `match-expr` library.

The Expression Language is easy enough to author expressions by hand,
certainly no more difficult than spreadsheet formulas. However, it's
designed to be generated by a user interface --- an interchange format
rather than a programming language proper.

_Note:_ If you're like me, you prefer to see a lot of examples rather
than plod through prose. See the [Examples][Examples] section to get a good idea
what the expressions look like and what they attempt to achieve.

# Expression Evaluation

The general use case for the language is an application that applies
each expression to a bunch of key/value hash maps in a data store,
looking for matches, something like this bit of pseudo-Python:

```python
class Rule:
  expr = '(and (= :a "1") (= :b "2"))'
  groups = ["Cool", "Snazzy"]

def filterObjects(objects, rule):
    matches = []
    for object in objects:
        if eval(object, rule.expr):
            matches.append([object.id, rule.groups])
        return matches
```

Based on matches, the application assigns groups (just strings,
basically) to the object. You can imagine this as a way to take lots
of related (but differently attributed objects) and grouping them
appropriately. A data integration kind of thing.

In other words, the Expression Langauge is a pattern-matching
language for matching object attributes, similar to (say) the way
regular expressions match strings.

How does it work?

Read on!

# Value Objects

The purpose of the Expression Language to match against specific
value objects (hash-maps). If the expression "matches" an asset, it returns
true, if not, false.

An asset is a collection of attributes. Each clause in the language is
an expression that can match against one of those attributes. One
attribute, one clause.

Here's what a typical "server" object looks like as far as the Expression
Language is concerned:

```clojure
{ :asset-id : "A001"
  :location : "east"
  :os       : "unix"
  :hostname : "ed5d.z.host.com"
  :hostname : "8603.b.host.com"
  :hostname : "5967.b.host.com"
  :ipv4     : "10.32.159.141"
  :ipv4     : "192.168.32.110"
  :ipv4     : "172.16.32.46"
  :arch     : "itanium"
  :app      : "oracle"
  :nameserv : "192.168.10.10"
  :nameserv : "192.168.99.99"
  :platform : "hpux"  }
```

Yes, it's possible for any given attribute to have more than one
value.

The goal of the Expression Language is to search for and find specific
objects via the values attached to their attributes, but to not
require any specific attribute on input.

Here's an example of a typical expression:

```clojure
(and (= :location "east")
     (= :os "unix"))
```

This expression returns true when applied to the above example object
because the attributes in the matching clauses: `:location` and `:os`
match the values in the asset: "east" and "unix". (See more
[Examples][Examples] below.)

The use of `and` in the above is a _logical_ clause because it's made
up of other clauses, rather than being one itself.

Anyway, lets get into more detail.

# Clauses

An expression is made up of _matching_ clauses and _logical_ clauses.

## Matching Clauses

A _match_ clause has the following form:

```clojure
(operator :attribute value)
```

Three elements that can be evaluated to "true" or "false" when applied
to a value named by the attribute. A clause uses prefix notation, the
same as the Lisp family of languages.

Details:

 - **operator** <br/> An operator is a function of some sort, like `=`,
  `not=` or `match`. See [Operators][Operators] for details. An
  operator might also be a _logical_ operator, which is a way to group
  clauses together so that you can express "all must match" and "any
  can match" semantics.

 - **attribute** <br/> An attribute is the name of a value attached to
   an object. For instance: `:name`, `:ipv4`,
   `:network-group` and so on.

 - **value** <br/> The value represents what you expect the attribute
   to be for the clause to return true, depending on the operator. For
   instance, "my.host.com" or "^.*foo.com$".

All _matching_-style clauses are made up of those three terms.

## Logical Clauses

Clauses can be nested to an arbitrary depth by logical operators.

```clojure
(and (or clause
         (and clause clause)
         clause)
     (and clause
          clause
          clause))
```

The `and` and `or` operators are just what you'd expect from other
programming languages, though in this case, you can have as many
_matching_ or _logical_ clauses as parameters to an `or` or `and`
operator.

(It's much easier to see this as an example than express it in
language.)

### OR expressions

The following expression:

```clojure
(or logical-or-match-clause
    logical-or-match-clause
    logical-or-match-clause)
```

evaluates to "true" if _any one_ of the clauses evaluates to true.

### AND expressions

The following expression:

```clojure
(and logical-or-match-clause
     logical-or-match-clause
     logical-or-match-clause)
```

evaluates to "true" if and only if _all_ of the clauses evaluates to
true.

# Operators

Operators are really just functions that take an attribute and a
value. It's implied that the attribute is attached to a specific
asset.

**Important**: If a clause contains an attribute that doesn't exist
for a given asset, it'll return false, which is not necessarily a bad
thing. That's why we have the `or` logical operator.

## Matching Operators

Right now, you can use the following operators as part of any
expression clause:

| Operator | Function                   | Example                     |
|----------|----------------------------|-----------------------------|
| =        | exact match                | (= :p "192.168.1.10")       |
| not=     | does not match             | (not= :p "foo")             |
| cidr     | match on network CIDR      | (cidr :p "192.168/16")      |
| match    | regular expression match   | (match :p "^.*host.com")    |

## Numerical Operators

The following operators assume numeric attribute values.

| Operator | Function                   | Example                     |
|----------|----------------------------|-----------------------------|
| >        | greater than               | (> :p 23)                   |
| <        | less than                  | (< :p 33)                   |
| <=       | less than or equal to      | (<= :p 33)                  |
| >=       | greather than or equal to  | (>= :p 44)                  |

## Logical Operators

The following are logical operators which let you use boolean logic in
relating one clause to another.

| Operator | Function                   | Example                     |
|----------|----------------------------|-----------------------------|
| and      | less than or equal to      | (and (<= :p 33) (>= :p 44)) |
| or       | true of any clause is true | (or (>= :p 100) (<= :p 50)) |

# Examples

In general, expressions can use the operators as defined above and
can use just about any value that makes sense (a match must use a
regex, a numeric operator must use a number).

The following are a few examples about the kinds of things you can do
with the expression language.

The following rule matches a value object describing a server running
Windows that has a hostname ending in "b.host.com":

```clojure
(and (= :os "windows")
     (match :hostname "*.host.com"))
```

The following rule matches a server value object with a score in a
particular range that's also a web server of some sort:

```clojure
(and (and (>= :score 26)
          (<= :score 75))
     (or (= :app "apache")
         (= :app "nginx")
         (= :app "iis")))
```

The following rule matches a server value object on a certain network,
with a certain name server. Note that this particular expression can
handle assets with different attributes that mean the same thing, in
this case, `ipv4`, `ip` and `inet-address`, all of which mean the same
thing but come from different taxonomies.


```clojure
(and (or (cidr :asset/ipv4 "144.64.3/24")
         (cidr :asset/inet-address "144.64.3/24")
         (cidr :asset/ip "144.64.3/24"))
     (= :asset/nameserver "8.8.8.8"))
```

Ultimately, the best way to learn to use the expressions is to try
them out, which is beyond the scope of this document.

# Formal Grammar (EBNF)

If you're in to these sorts of things, here's the EBNF notatation for
the Expression Language. It should be useful for generating parsers in
your favorite language.

    rule       = bool-exp | match-exp | math-exp
    bool-exp   = space* <'('> logic-op space+ rule+ <')'> space*
    match-exp  = space* <'('> basic-op space+ attribute space+ value <')'> space*
    math-exp   = space* <'('> math-op space+ attribute space+ integer <')'> space*
    <space>    = <#'[ \t\n,]*'>
    operator   = basic-op | logic-op
    <basic-op> = equals | not-equals | match | cidr
    <logic-op> = and | or
    <math-op>  = '<' | '>' | '<=' | '>='
    equals     = <'='>
    not-equals = <'not='>
    match      = <'match'>
    cidr       = <'cidr'>
    or         = <'or'>
    and        = <'and'>
    attribute  = #':[^ \t\n]+'
    <value>    = string | integer
    string     = dquote #'[A-Za-z0-9^$.*?+<>{}()@#: /\\\\]*' dquote
    integer    = #'[0-9]+'
    <dquote>   = <'\"'>


Note: This isn't actually used (yet) in the code.
